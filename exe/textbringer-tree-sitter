#!/usr/bin/env ruby
# frozen_string_literal: true

require "fileutils"
require "open-uri"
require "tmpdir"
require "open3"
require "yaml"
require "digest"
require "json"
require "rubygems/package"
require "zlib"

# Load LanguageAliases for normalization
require_relative "../lib/textbringer/tree_sitter/language_aliases"
require_relative "../lib/textbringer/tree_sitter/platform"

module TextbringerTreeSitterCLI
  FAVEOD_VERSION = "v4.11"

  # Faveod tarball ã«å«ã¾ã‚Œã‚‹ parser
  FAVEOD_PARSERS = %w[
    bash c c-sharp cobol embedded-template groovy haml html
    java javascript json pascal php python ruby rust
  ].freeze

  # è¦ãƒ“ãƒ«ãƒ‰ï¼ˆFaveod ã«å«ã¾ã‚Œãªã„ï¼‰
  BUILD_PARSERS = {
    hcl: {
      repo: "mitchellh/tree-sitter-hcl",
      branch: "main",
      build_cmd: ->(src_dir, out_file) {
        "c++ -shared -fPIC -O2 -std=c++14 -I#{src_dir}/src #{src_dir}/src/parser.c #{src_dir}/src/scanner.cc -o #{out_file}"
      }
    },
    yaml: {
      repo: "tree-sitter-grammars/tree-sitter-yaml",
      branch: "master",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c #{src_dir}/src/scanner.c -o #{out_file}"
      }
    },
    go: {
      repo: "tree-sitter/tree-sitter-go",
      branch: "master",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c -o #{out_file}"
      }
    },
    typescript: {
      repo: "tree-sitter/tree-sitter-typescript",
      branch: "master",
      subdir: "typescript",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c #{src_dir}/src/scanner.c -o #{out_file}"
      }
    },
    tsx: {
      repo: "tree-sitter/tree-sitter-typescript",
      branch: "master",
      subdir: "tsx",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c #{src_dir}/src/scanner.c -o #{out_file}"
      }
    },
    sql: {
      repo: "m-novikov/tree-sitter-sql",
      branch: "main",
      build_cmd: ->(src_dir, out_file) {
        # scanner.cc requires C++
        "c++ -shared -fPIC -O2 -std=c++14 -I#{src_dir}/src #{src_dir}/src/parser.c #{src_dir}/src/scanner.cc -o #{out_file}"
      }
    },
    markdown: {
      repo: "tree-sitter-grammars/tree-sitter-markdown",
      branch: "split_parser",
      commit: "9a23c1a",  # LANGUAGE_VERSION 14 (ruby_tree_sitter äº’æ›)
      subdir: "tree-sitter-markdown",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c #{src_dir}/src/scanner.c -o #{out_file}"
      }
    },
    crystal: {
      repo: "crystal-lang-tools/tree-sitter-crystal",
      branch: "main",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c #{src_dir}/src/scanner.c -o #{out_file}"
      }
    },
    elixir: {
      repo: "elixir-lang/tree-sitter-elixir",
      branch: "main",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c #{src_dir}/src/scanner.c -o #{out_file}"
      }
    },
    kotlin: {
      repo: "fwcd/tree-sitter-kotlin",
      branch: "main",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c -o #{out_file}"
      }
    },
    swift: {
      repo: "alex-pinkus/tree-sitter-swift",
      branch: "main",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c -o #{out_file}"
      }
    },
    zig: {
      repo: "tree-sitter-grammars/tree-sitter-zig",
      branch: "master",
      build_cmd: ->(src_dir, out_file) {
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c -o #{out_file}"
      }
    }
  }.freeze

  # Configuration class for language parsers
  class LanguageConfig
    attr_reader :name, :repo, :branch, :commit, :subdir, :build_cmd, :source

    def initialize(name, config)
      @name = name.to_s
      @source = config[:source] || config["source"] || :github

      if @source == :faveod
        # Faveod prebuilt - no repo needed
        @repo = nil
        @branch = nil
        @commit = nil
        @subdir = nil
        @build_cmd = nil
      else
        # GitHub source
        @repo = config[:repo] || config["repo"]
        unless @repo
          raise ArgumentError, "Missing 'repo' for language: #{name}"
        end

        @branch = config[:branch] || config["branch"] || "main"
        @commit = config[:commit] || config["commit"]
        @subdir = config[:subdir] || config["subdir"]
        @build_cmd = config[:build_cmd] || config["build_cmd"]
      end
    end

    def faveod?
      @source == :faveod
    end

    def github?
      @source == :github
    end

    def to_hash
      if faveod?
        {
          repo: repo,
          branch: branch,
          build_cmd: build_cmd
        }
      else
        result = { repo: repo, branch: branch }
        result[:commit] = commit if commit
        result[:subdir] = subdir if subdir
        result[:build_cmd] = build_cmd if build_cmd
        result
      end
    end
  end

  class << self
    def checksums_file
      File.expand_path("~/.textbringer/parsers/checksums.json")
    end

    def load_checksums
      return {} unless File.exist?(checksums_file)

      begin
        JSON.parse(File.read(checksums_file))
      rescue => e
        warn "Warning: Failed to load checksums: #{e.message}"
        {}
      end
    end

    def save_checksums(checksums)
      FileUtils.mkdir_p(File.dirname(checksums_file))
      File.write(checksums_file, JSON.pretty_generate(checksums))
    end

    def compute_checksum(file_path)
      Digest::SHA256.file(file_path).hexdigest
    end

    def verify_checksum(file_path, url)
      checksums = load_checksums
      actual = compute_checksum(file_path)

      if checksums.key?(url)
        expected = checksums[url]
        if actual != expected
          raise "Checksum verification failed for #{url}\n" \
                "  Expected: #{expected}\n" \
                "  Got:      #{actual}"
        end
        puts "  Checksum verified: #{actual[0..15]}..."
      else
        # First download - record checksum
        checksums[url] = actual
        save_checksums(checksums)
        puts "  Checksum recorded: #{actual[0..15]}..."
      end
    end

    def user_config_file
      File.expand_path("~/.textbringer/tree_sitter/languages.yml")
    end

    def load_curated_languages
      result = {}

      # Faveod prebuilt parsers
      FAVEOD_PARSERS.each do |lang|
        result[lang] = LanguageConfig.new(lang, { source: :faveod })
      end

      # Build-required parsers
      BUILD_PARSERS.each do |lang_sym, config|
        lang = lang_sym.to_s.tr("_", "-")
        result[lang] = LanguageConfig.new(lang, config)
      end

      result
    end

    def load_user_languages
      return {} unless File.exist?(user_config_file)

      begin
        yaml = YAML.load_file(user_config_file)
        return {} unless yaml.is_a?(Hash)

        yaml.transform_keys(&:to_s).map do |name, config|
          [name, LanguageConfig.new(name, config)]
        end.to_h
      rescue => e
        warn "Warning: Failed to load user config: #{e.message}"
        {}
      end
    end

    def all_languages
      curated = load_curated_languages
      user_defined = load_user_languages

      # User config overrides curated
      curated.merge(user_defined)
    end

    def platform
      Textbringer::TreeSitter::Platform.platform
    end

    def faveod_platform
      Textbringer::TreeSitter::Platform.faveod_platform
    end

    def dylib_ext
      Textbringer::TreeSitter::Platform.dylib_ext
    end

    def parser_dir
      File.expand_path("~/.textbringer/parsers/#{platform}")
    end

    def parser_installed?(language)
      # Normalize language name to handle aliases
      normalized = Textbringer::TreeSitter::LanguageAliases.normalize(language)
      filename = "libtree-sitter-#{normalized}#{dylib_ext}"
      File.exist?(File.join(parser_dir, filename))
    end

    def download_faveod_parser(language)
      # Check for opt-out environment variable
      if ENV["TEXTBRINGER_TREE_SITTER_NO_DOWNLOAD"]
        puts "Error: TEXTBRINGER_TREE_SITTER_NO_DOWNLOAD is set - downloads are disabled"
        puts ""
        puts "To install manually:"
        puts "  1. Download from https://github.com/Faveod/tree-sitter-parsers/releases"
        puts "  2. Extract to #{parser_dir}"
        return false
      end

      # Normalize language name to handle aliases
      normalized = Textbringer::TreeSitter::LanguageAliases.normalize(language)

      # Faveod tarball ã‹ã‚‰ç‰¹å®šã® parser ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
      filename = "libtree-sitter-#{normalized}#{dylib_ext}"
      dest_path = File.join(parser_dir, filename)

      if File.exist?(dest_path)
        puts "#{normalized}: already installed"
        return true
      end

      url = "https://github.com/Faveod/tree-sitter-parsers/releases/download/#{FAVEOD_VERSION}/tree-sitter-parsers-#{FAVEOD_VERSION.delete('v')}-#{faveod_platform}.tar.gz"

      puts "Downloading #{normalized} from Faveod..."

      Dir.mktmpdir do |tmpdir|
        tarball = File.join(tmpdir, "parsers.tar.gz")

        begin
          URI.open(url, "rb") do |remote|
            File.open(tarball, "wb") { |f| f.write(remote.read) }
          end
        rescue OpenURI::HTTPError => e
          puts "  Error: Failed to download: #{e.message}"
          return false
        end

        # Verify checksum
        begin
          verify_checksum(tarball, url)
        rescue => e
          puts "  Error: #{e.message}"
          return false
        end

        extract_dir = File.join(tmpdir, "extracted")
        FileUtils.mkdir_p(extract_dir)
        unless extract_tarball(tarball, extract_dir)
          return false
        end

        # Faveod tarball å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«åã¯æ­£è¦åŒ–å‰ã®åå‰ï¼ˆä¾‹: c-sharpï¼‰ã®å ´åˆãŒã‚ã‚‹
        faveod_filename = "libtree-sitter-#{language}#{dylib_ext}"
        src = Dir.glob("#{extract_dir}/**/#{filename}").first
        src ||= Dir.glob("#{extract_dir}/**/#{faveod_filename}").first if filename != faveod_filename
        if src
          FileUtils.mkdir_p(parser_dir)
          FileUtils.cp(src, dest_path)
          FileUtils.chmod(0o755, dest_path)
          puts "  -> #{dest_path}"
          true
        else
          puts "  Error: #{normalized} not found in tarball"
          false
        end
      end
    end

    def build_parser(language)
      # Normalize language name to handle aliases
      normalized = Textbringer::TreeSitter::LanguageAliases.normalize(language)
      # Legacy method - delegates to config-based method
      lang_sym = normalized.to_s.gsub("-", "_").to_sym
      info = BUILD_PARSERS[lang_sym]

      unless info
        puts "Error: Unknown build-required language: #{language}"
        puts "Available: #{BUILD_PARSERS.keys.join(', ')}"
        return false
      end

      config = LanguageConfig.new(normalized, info)
      build_parser_from_config(normalized, config)
    end

    def build_parser_from_config(language, config)
      # Check for opt-out environment variable
      if ENV["TEXTBRINGER_TREE_SITTER_NO_DOWNLOAD"]
        puts "Error: TEXTBRINGER_TREE_SITTER_NO_DOWNLOAD is set - downloads are disabled"
        puts ""
        puts "To build manually:"
        puts "  1. Clone https://github.com/#{config.repo}"
        puts "  2. Build using the instructions in the repository"
        puts "  3. Copy the library to #{parser_dir}"
        return false
      end

      filename = "libtree-sitter-#{language}#{dylib_ext}"
      dest_path = File.join(parser_dir, filename)

      if File.exist?(dest_path)
        puts "#{language}: already installed"
        return true
      end

      puts "Building #{language} parser..."
      puts "  Repository: #{config.repo}"

      Dir.mktmpdir do |tmpdir|
        repo_dir = File.join(tmpdir, "repo")

        puts "  Cloning..."
        if config.commit
          # ç‰¹å®šã‚³ãƒŸãƒƒãƒˆãŒå¿…è¦ãªå ´åˆã¯ shallow clone ã§ããªã„
          _, status = Open3.capture2e("git", "clone", "-b", config.branch,
                                      "https://github.com/#{config.repo}.git", repo_dir)
          unless status.success?
            puts "  Error: Failed to clone repository"
            return false
          end

          puts "  Checking out #{config.commit}..."
          _, status = Open3.capture2e("git", "-C", repo_dir, "checkout", config.commit)
          unless status.success?
            puts "  Error: Failed to checkout commit #{config.commit}"
            return false
          end
        else
          _, status = Open3.capture2e("git", "clone", "--depth", "1", "-b", config.branch,
                                      "https://github.com/#{config.repo}.git", repo_dir)
          unless status.success?
            puts "  Error: Failed to clone repository"
            return false
          end
        end

        src_dir = config.subdir ? File.join(repo_dir, config.subdir) : repo_dir

        # Use custom build command or auto-detect
        build_cmd = if config.build_cmd
                      if config.build_cmd.is_a?(Proc)
                        config.build_cmd.call(src_dir, dest_path)
                      else
                        # String template: replace {src} and {output}
                        config.build_cmd.gsub("{src}", src_dir).gsub("{output}", dest_path)
                      end
                    else
                      guess_build_cmd(src_dir, dest_path)
                    end

        puts "  Building..."
        FileUtils.mkdir_p(parser_dir)
        output, status = Open3.capture2e(build_cmd)

        unless status.success?
          puts "  Error: Build failed"
          puts output
          return false
        end

        FileUtils.chmod(0o755, dest_path)
        puts "  -> #{dest_path}"
        true
      end
    end

    def guess_build_cmd(src_dir, out_file)
      # Auto-detect based on scanner file
      scanner = Dir.glob("#{src_dir}/src/scanner.{c,cc}").first
      if scanner
        ext = File.extname(scanner)
        compiler = ext == ".cc" ? "c++" : "cc"
        std_flag = ext == ".cc" ? "-std=c++14" : "-std=c99"
        "#{compiler} -shared -fPIC -O2 #{std_flag} -I#{src_dir}/src #{src_dir}/src/parser.c #{scanner} -o #{out_file}"
      else
        "cc -shared -fPIC -O2 -I#{src_dir}/src #{src_dir}/src/parser.c -o #{out_file}"
      end
    end

    def extract_tarball(tarball_path, extract_dir)
      expanded_extract_dir = File.expand_path(extract_dir)
      File.open(tarball_path, "rb") do |file|
        Zlib::GzipReader.wrap(file) do |gz|
          Gem::Package::TarReader.new(gz) do |tar|
            tar.each do |entry|
              next unless entry.file?
              dest = File.expand_path(File.join(extract_dir, entry.full_name))
              unless dest.start_with?("#{expanded_extract_dir}/")
                raise "Path traversal detected: #{entry.full_name}"
              end
              FileUtils.mkdir_p(File.dirname(dest))
              File.open(dest, "wb") { |f| f.write(entry.read) }
            end
          end
        end
      end
      true
    rescue Zlib::GzipFile::Error, Gem::Package::TarInvalidError => e
      puts "  Error: Failed to extract tarball: #{e.message}"
      false
    end

    def get_parser(language)
      # Normalize language name to handle aliases
      normalized = Textbringer::TreeSitter::LanguageAliases.normalize(language)
      languages = all_languages

      # normalized form ã§æ¯”è¼ƒã—ã¦ä¸€è‡´ã™ã‚‹ã‚¨ãƒ³ãƒˆãƒªã‚’æ¢ã™
      lang, config = languages.find { |k, _|
        Textbringer::TreeSitter::LanguageAliases.normalize(k) == normalized
      }

      unless config
        puts "Error: Unknown language: #{language}"
        puts ""
        puts "Available languages:"
        curated = load_curated_languages
        user_defined = load_user_languages

        if curated.any?
          puts "  Curated: #{curated.keys.sort.join(', ')}"
        end
        if user_defined.any?
          puts "  User-defined: #{user_defined.keys.sort.join(', ')}"
        end
        puts ""
        puts "To add custom languages, run: textbringer-tree-sitter init"
        return false
      end

      # Faveod prebuilt
      if config.faveod?
        download_faveod_parser(lang)
      # GitHub build required
      else
        build_parser_from_config(lang, config)
      end
    end

    def list_parsers
      curated = load_curated_languages
      user_defined = load_user_languages

      puts "=== Curated Languages (built-in) ==="
      puts "[S] = Supported in gem"
      puts "[âœ“] = Installed"
      puts ""

      # Group curated by source
      faveod_langs = curated.select { |_, config| config.faveod? }
      build_langs = curated.select { |_, config| config.github? }

      puts "Faveod Prebuilt:"
      faveod_langs.keys.sort.each do |lang|
        status = parser_installed?(lang) ? "âœ“" : " "
        repo = "Faveod/tree-sitter-parsers"
        puts "  [S][#{status}] #{lang.ljust(20)} #{repo}"
      end

      puts ""
      puts "Build-required:"
      build_langs.sort.each do |lang, config|
        status = parser_installed?(lang) ? "âœ“" : " "
        repo = config.repo || "(unknown)"
        puts "  [S][#{status}] #{lang.ljust(20)} #{repo}"
      end

      if user_defined.any?
        puts ""
        puts "=== User-defined Languages (~/.textbringer/tree_sitter/languages.yml) ==="
        puts "[U] = User-defined"
        puts ""

        user_defined.sort.each do |lang, config|
          status = parser_installed?(lang) ? "âœ“" : " "
          override = curated.key?(lang) ? " (overrides curated)" : ""
          source = config.faveod? ? "Faveod/tree-sitter-parsers" : config.repo
          puts "  [U][#{status}] #{lang.ljust(20)} #{source}#{override}"
        end
      end

      puts ""
      puts "ğŸ“ To add custom languages:"
      puts "   textbringer-tree-sitter init"
      puts ""
      puts "Use 'textbringer-tree-sitter get <lang>' to install"
    end

    def get_all
      # Check for opt-out environment variable
      if ENV["TEXTBRINGER_TREE_SITTER_NO_DOWNLOAD"]
        puts "Error: TEXTBRINGER_TREE_SITTER_NO_DOWNLOAD is set - downloads are disabled"
        puts ""
        puts "To install manually:"
        puts "  1. Download from https://github.com/Faveod/tree-sitter-parsers/releases"
        puts "  2. Extract to #{parser_dir}"
        return
      end

      puts "Installing all Faveod prebuilt parsers..."
      puts ""

      url = "https://github.com/Faveod/tree-sitter-parsers/releases/download/#{FAVEOD_VERSION}/tree-sitter-parsers-#{FAVEOD_VERSION.delete('v')}-#{faveod_platform}.tar.gz"

      puts "Downloading from Faveod..."
      puts "  URL: #{url}"

      Dir.mktmpdir do |tmpdir|
        tarball = File.join(tmpdir, "parsers.tar.gz")

        begin
          URI.open(url, "rb") do |remote|
            File.open(tarball, "wb") { |f| f.write(remote.read) }
          end
        rescue OpenURI::HTTPError => e
          puts "  Error: Failed to download: #{e.message}"
          return
        end

        # Verify checksum
        begin
          verify_checksum(tarball, url)
        rescue => e
          puts "  Error: #{e.message}"
          return
        end

        extract_dir = File.join(tmpdir, "extracted")
        FileUtils.mkdir_p(extract_dir)
        unless extract_tarball(tarball, extract_dir)
          return
        end

        FileUtils.mkdir_p(parser_dir)

        Dir.glob("#{extract_dir}/**/libtree-sitter-*#{dylib_ext}").each do |src|
          filename = File.basename(src)
          dest = File.join(parser_dir, filename)

          if File.exist?(dest)
            puts "  #{filename} -> already installed"
          else
            FileUtils.cp(src, dest)
            FileUtils.chmod(0o755, dest)
            puts "  #{filename} -> OK"
          end
        end
      end

      puts ""
      puts "Done!"
    end

    def node_map_dir
      File.expand_path("~/.textbringer/tree_sitter/node_maps")
    end

    def guess_face(node_name)
      name = node_name.to_s.downcase
      case name
      when /comment/
        :comment
      when /string|heredoc|char_literal|template_string/
        :string
      when /number|integer|float|decimal|numeric/
        :number
      when /\b(if|else|elsif|unless|case|when|while|until|for|do|end|begin|rescue|ensure|return|yield|break|next|redo|retry|raise|class|module|def|alias|defined|super|self|nil|true|false|and|or|not|in|fn|func|function|let|const|var|import|export|from|as|try|catch|finally|throw|async|await|match|loop|struct|enum|impl|trait|pub|mut|ref|use|mod|crate|where|type|interface|package|extends|implements|static|final|abstract|native|synchronized|volatile|transient|new|this|instanceof|goto|switch|default|continue|assert|with|pass|lambda|nonlocal|global|del|except|exec|print|elif|is)\b/
        :keyword
      when /keyword|reserved/
        :keyword
      when /constant|boolean/
        :constant
      when /function_name|method_name|call|invocation/
        :function_name
      when /type|class_name|struct_name|interface_name/
        :type
      when /variable|identifier|name/
        :variable
      when /operator|binary_op|unary_op/
        :operator
      when /punctuation|delimiter|bracket|paren|brace/
        :punctuation
      when /marker|heading|header/
        :keyword
      else
        nil
      end
    end

    def generate_node_map(language)
      # Normalize language name to handle aliases
      normalized = Textbringer::TreeSitter::LanguageAliases.normalize(language)
      lang = normalized.to_s.gsub("-", "_")
      filename = "libtree-sitter-#{normalized}#{dylib_ext}"
      parser_path = File.join(parser_dir, filename)

      unless File.exist?(parser_path)
        puts "Error: Parser not installed. Run 'textbringer-tree-sitter get #{language}' first."
        return false
      end

      require "tree_sitter"

      begin
        ts_lang = TreeSitter::Language.load(lang, parser_path)
      rescue => e
        puts "Error: Failed to load parser: #{e.message}"
        return false
      end

      # ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’åé›†ã—ã¦ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ã§ãƒãƒƒãƒ”ãƒ³ã‚°
      mappings = {}
      unmapped = []

      ts_lang.symbol_count.times do |i|
        name = ts_lang.symbol_name(i)
        next if name.nil? || name.empty?
        next if name.start_with?("_")  # internal nodes
        next if name.length == 1       # single char tokens
        next if name =~ /^[^a-zA-Z]/   # non-alphabetic

        face = guess_face(name)
        if face
          mappings[face] ||= []
          mappings[face] << name unless mappings[face].include?(name)
        else
          unmapped << name unless unmapped.include?(name)
        end
      end

      # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
      const_name = lang.upcase
      output = <<~RUBY
        # frozen_string_literal: true

        # Auto-generated node map for #{language}
        # Generated by: textbringer-tree-sitter get #{language} --generate-map
        #
        # Review and customize as needed.
        # Uncommented mappings are heuristic guesses.
        # Commented lines are unmapped nodes.

        module Textbringer
          module TreeSitter
            module NodeMaps
              #{const_name}_FEATURES = {
      RUBY

      # ãƒãƒƒãƒ”ãƒ³ã‚°æ¸ˆã¿ã‚’å‡ºåŠ›
      mappings.each do |face, nodes|
        nodes_str = nodes.join(" ")
        output << "          #{face}: %i[#{nodes_str}],\n"
      end

      output << "        }.freeze\n\n"

      # æœªãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§å‡ºåŠ›
      if unmapped.any?
        output << "        # Unmapped nodes (add to appropriate face if needed):\n"
        unmapped.each do |name|
          output << "        #   #{name}\n"
        end
        output << "\n"
      end

      output << <<~RUBY
              #{const_name} = #{const_name}_FEATURES.flat_map { |face, nodes|
                nodes.map { |node| [node, face] }
              }.to_h.freeze

              # è‡ªå‹•ç™»éŒ²
              register(:#{lang}, #{const_name})
            end
          end
        end
      RUBY

      # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã—
      FileUtils.mkdir_p(node_map_dir)
      dest_path = File.join(node_map_dir, "#{lang}.rb")
      File.write(dest_path, output)

      puts "Generated node map: #{dest_path}"
      puts "  Mapped: #{mappings.values.flatten.size} nodes"
      puts "  Unmapped: #{unmapped.size} nodes (commented)"
      puts ""
      puts "Edit the file to customize mappings, then add to ~/.textbringer.rb:"
      puts "  require '#{dest_path}'"
      true
    end

    def init_config
      config_file = user_config_file
      config_dir = File.dirname(config_file)

      if File.exist?(config_file)
        puts "Config file already exists: #{config_file}"
        puts ""
        puts "Edit this file to add custom languages."
        return true
      end

      FileUtils.mkdir_p(config_dir)

      template = <<~YAML
        # Custom Tree-sitter Languages Configuration
        # File: ~/.textbringer/tree_sitter/languages.yml
        #
        # Add custom languages not included in the gem.
        # User-defined languages override curated ones.

        # Example 1: Simple format (minimal config)
        # elixir:
        #   repo: elixir-lang/tree-sitter-elixir

        # Example 2: Detailed format (full control)
        # zig:
        #   repo: maxxnino/tree-sitter-zig
        #   branch: master
        #   commit: abc123  # Optional: pin to specific commit
        #   subdir: ""      # Optional: subdirectory within repo
        #   build_cmd: "cc -shared -fPIC -O2 -I{src}/src {src}/src/parser.c -o {output}"

        # Example 3: Override curated language (use fork)
        # ruby:
        #   repo: my-username/tree-sitter-ruby
        #   branch: experimental

        # Example 4: Faveod prebuilt (skip build)
        # groovy:
        #   source: faveod

        # Add your custom languages below:
      YAML

      File.write(config_file, template)
      puts "Created: #{config_file}"
      puts ""
      puts "Add custom languages by editing this file."
      puts ""
      puts "Example:"
      puts "  elixir:"
      puts "    repo: elixir-lang/tree-sitter-elixir"
      puts "    branch: main"
      puts ""
      puts "Then install with:"
      puts "  textbringer-tree-sitter get elixir"
      true
    end

    def show_help
      puts <<~HELP
        textbringer-tree-sitter - Parser manager for textbringer-tree-sitter

        Usage:
          textbringer-tree-sitter list                List available parsers
          textbringer-tree-sitter get <lang>          Download/build parser + generate node_map
          textbringer-tree-sitter get <lang> --no-map Download/build parser only (skip node_map)
          textbringer-tree-sitter get-all             Install all Faveod prebuilt parsers
          textbringer-tree-sitter generate-map <lang> (Re)generate node_map for installed parser
          textbringer-tree-sitter init                Create user config file for custom languages
          textbringer-tree-sitter path                Show parser directory

        Examples:
          textbringer-tree-sitter get markdown        Build parser + generate node_map
          textbringer-tree-sitter get ruby            Download Ruby parser + generate node_map
          textbringer-tree-sitter get-all             Install all prebuilt parsers (no node_maps)
          textbringer-tree-sitter init                Create ~/.textbringer/tree_sitter/languages.yml
      HELP
    end

    def run(args)
      command = args[0]

      case command
      when "init"
        init_config
      when "list"
        list_parsers
      when "get"
        lang = args[1]
        if lang.nil?
          puts "Error: Please specify a language"
          puts "Usage: textbringer-tree-sitter get <lang>"
          exit 1
        end
        skip_map = args.include?("--no-map")
        success = get_parser(lang)
        if success && !skip_map
          # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ node_map ãŒã‚ã‚‹è¨€èªã¯ã‚¹ã‚­ãƒƒãƒ—
          default_node_map_languages = %w[
            bash c cobol crystal csharp elixir groovy haml hcl html java javascript
            json pascal php python ruby rust sql swift yaml
          ]
          # Normalize for comparison
          lang_normalized = Textbringer::TreeSitter::LanguageAliases.normalize(lang)
          if default_node_map_languages.include?(lang_normalized)
            puts ""
            puts "Using default node_map for #{lang_normalized} (included in gem)"
          else
            puts ""
            generate_node_map(lang)
          end
        end
        exit(success ? 0 : 1)
      when "get-all"
        get_all
      when "generate-map"
        lang = args[1]
        if lang.nil?
          puts "Error: Please specify a language"
          puts "Usage: textbringer-tree-sitter generate-map <lang>"
          exit 1
        end
        success = generate_node_map(lang)
        exit(success ? 0 : 1)
      when "path"
        puts parser_dir
      when "help", "--help", "-h", nil
        show_help
      else
        puts "Unknown command: #{command}"
        show_help
        exit 1
      end
    end
  end
end

# Only run CLI if executed directly (not when loaded by tests)
if __FILE__ == $PROGRAM_NAME
  TextbringerTreeSitterCLI.run(ARGV)
end
